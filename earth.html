<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Three.js - Texture Mapping</title>
<style>
img{display:none;}
* {
margin: 0;
padding: 0;
box-sizing: border-box;
font-family: -applesystem, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,
Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}
html,
body {
height: 100vh;
width: 100vw;
}
#threejs-container {
position: block;
width: 100%;
height: 100%;
}
</style>
</head>
<body>
<div id="threejs-container"></div>

<script type="importmap">
{"imports":{
"three":"https://threejs.org/build/three.module.js",
"three/addons/":"https://threejs.org/examples/jsm/"}}
</script>
<script type="module">
import {OrbitControls} from "three/addons/controls/OrbitControls.js";
import * as THREE from 'three';
import {GUI} from 'three/addons/libs/lil-gui.module.min.js';

//const gui=new GUI();
let width = 500
let height = 500
// scene
const scene = new THREE.Scene()
scene.background = new THREE.Color(0x111)


// lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
scene.add(ambientLight)
const light = new THREE.DirectionalLight(0xffffff,1)
light.position.set(10, 10, 0)
light.castShadow = true
light.shadow.mapSize.width = 512
light.shadow.mapSize.height = 512
light.shadow.camera.near = 0.5
light.shadow.camera.far = 100
scene.add(light)

// renderer - anti-aliasing
const renderer = new THREE.WebGLRenderer({ antialias: true })
renderer.physicallyCorrectLights = true
renderer.setSize(width, height)
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

// camera
const camera = new THREE.PerspectiveCamera(45, width / height, 0.01, 100)
camera.position.set(0,0,50)


const controls= new OrbitControls(camera, renderer.domElement)
controls.autoRotate=true
controls.autoRotateSpeed=5


// textures
var images=document.querySelectorAll("img");
const loader = new THREE.TextureLoader()

const texture = loader.load('neon.png')
// plane
const planeGeometry = new THREE.PlaneGeometry(100, 100,5,5)
const plane = new THREE.Mesh(
planeGeometry,
new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide, wireframe: true })
)
plane.rotateX(-Math.PI / 2)
plane.position.y = -12.75
plane.receiveShadow = true
scene.add(plane)
// object
const geometry = new THREE.SphereGeometry(10, 360, 60)
const material1 = new THREE.MeshStandardMaterial({
wireframe:true,
map: texture,
side: THREE.DoubleSide
})
const object1 = new THREE.Mesh(geometry, material1)
object1.position.set(0,0, 0)
object1.castShadow = true
object1.receiveShadow = true
scene.add(object1)

const transverse = new THREE.LineBasicMaterial({
color: 0x00ff00,
linewidth: '6'
});

//location 
var geo
function getLocation() {     
    if (navigator.geolocation) {       
              navigator.geolocation.getCurrentPosition(showPosition, showError);
     } else {
              x.innerHTML = "Geolocation is not supported by this browser.";
          } }

function showPosition(position) {
   var latlon = position.coords.latitude + "," + position.coords.longitude;
   geo=[ position.coords.latitude , position.coords.longitude];
     }

function showError(error) {
    switch(error.code) {
        case error.PERMISSION_DENIED:
         x.innerHTML = "User denied the request for Geolocation."
           break;
        case error.POSITION_UNAVAILABLE:
             x.innerHTML = "Location information is unavailable."
          break;
       case error.TIMEOUT:
             x.innerHTML = "The request to get user location timed out ."
          break;
       case error.UNKNOWN_ERROR:
             x.innerHTML = "An unknown error occurred." 
          break;     } }
getLocation();


const coord=[]
coord.push(new THREE.Vector3(0,0,0))
coord.push(new THREE.Vector3(0,11*Math.sin(Math.PI/180*geo[0]),11*Math.cos(Math.PI/180*geo[0])))

const refr = new THREE.BufferGeometry().setFromPoints(coord)

const loc = new THREE.Line(refr, transverse)
loc.position.set(0, 0, 0)
loc.rotation.y =Math.PI/180*(geo[1]+90)
scene.add(loc)

// cylinder
const c1geometry = new THREE.CylinderGeometry(0.5,0.5,.2,30,5,false,0,Math.PI*2)
const c1material = new THREE.MeshStandardMaterial({color: 0xffff00})
const magentaCylinder = new THREE.Mesh(c1geometry, c1material);
magentaCylinder.castShadow = true
magentaCylinder.receiveShadow = true
magentaCylinder.position.set(11*Math.sin(Math.PI/180*(geo[1]+90)),11*Math.sin(Math.PI/180*geo[0]), 11*Math.cos(Math.PI/180*geo[0])*Math.cos(Math.PI/180*(geo[1]+90)))
scene.add(magentaCylinder)

const points = []
points.push(new THREE.Vector3(0,-13,11))
points.push(new THREE.Vector3(0,10,11))

const ref = new THREE.BufferGeometry().setFromPoints(points)

const vertical = new THREE.Line(ref, transverse)
vertical.position.set(0, 0, 0)
scene.add(vertical)


// responsiveness
window.addEventListener('resize', () => {
width = window.innerWidth
height = window.innerHeight
camera.aspect = width / height
camera.updateProjectionMatrix()
renderer.setSize(window.innerWidth, window.innerHeight)
renderer.render(scene, camera)
})

// animation
function animate() {
requestAnimationFrame(animate)
let objects = [plane]
objects.forEach((i) => {
i.rotation.z +=-0.00875
})
vertical.rotation.y-=0.00875
magentaCylinder.rotation.y+=0.005
magentaCylinder.rotation.z+=0.005
renderer.render(scene, camera)
controls.update()
}
var canvas = renderer.domElement;
// rendering the scene
const container = document.querySelector('#threejs-container')
container.append(canvas)
renderer.render(scene, camera)
animate()
</script>
</body>
</html>
